theory catarin
begin


functions: h/2, mac/2

rule Setup_KDC:
     [ Fr(~k) ]
     --[ KDC_key(~k) ]->
     [ !KDC(~k, $kid) ]

rule KDC_Provision_Signer:
     let m = <'provision_signer', h(h(~k, $sid), $vid)>
     in
     [ !KDC(~k, $kid) ]
     --[ ProvisionKeyFor(~k, 'signer', <$kid, $sid, $vid>), Neq($sid, $vid) ]->
     [ ConfidentialAndAuthenticatedMessage($kid, $sid, m) ]

rule KDC_Provision_Verifier:
     let m = <'provision_verifier', h(~k, $vid)>
     in
     [ !KDC(~k, $kid) ]
     --[ ProvisionKeyFor(~k, 'verifier', <$kid, $vid>) ]->
     [ ConfidentialAndAuthenticatedMessage($kid, $vid, m) ]

rule Setup_Signer:
     let m = <'provision_signer', key>
     in
     [ ConfidentialAndAuthenticatedMessage($kid, $sid, m), Fr(~s) ]
     --[ SetupSigner(~s, $kid, $sid, key) ]->
     [ !Signer(~s, $kid, $sid, key) ]

rule Setup_Verifier:
     let m = <'provision_verifier', key>
     in
     [ ConfidentialAndAuthenticatedMessage($kid, $sid, m), Fr(~v) ]
     --[ SetupVerifier(~v, $kid, $sid, $vid, key) ]->
     [ !Verifier(~v, $kid, $sid, $vid, key) ]

rule Signer_Sign:
     let token = mac(~data, key)
     in
     [ !Signer(~s, $kid, $sid, key), Fr(~data) ]
     --[ Sign(~s, $kid, $sid, $vid, key, ~data) ]->
     [ Out(<token, ~data>) ]

rule Verifier_Verify:
     let mackey = h(key, $sid)
     token = mac(data, mackey)
     in
     [ In(<token, data>), !Verifier(~v, $kid, $sid, $vid, key) ]
     --[ Verified(data, $vid, key) ]->
     [ ]

rule Compromise_Verifier_Key:
     [ !Verifier(~v, $kid, $sid, $vid, key) ]
     --[ VCompromise(key) ]->
     [ Out(key) ]

rule Compromise_Signer_Key:
     [ !Signer(~s, $kid, $sid, key) ]
     --[ SCompromise(key) ]->
     [ Out(key) ]

lemma sane:
      exists-trace "Ex data vid key #j. Verified(data, vid, key) @ j"

lemma authenticated:
      "All data vid key #j. Verified(data, vid, key) @ j ==> (
           (Ex a b c d #i. Sign(a, b, c, d, vid, data) @ i)
	 | (Ex #i. VCompromise(key) @ i) // the verifier's key was compromised (i.e. KCI)
	 | (Ex skey #i. key=h(skey, vid) & SCompromise(skey) @ i) // the signer's key was compromised
       )
"

restriction neq_impl: "All x y #i. Neq(x, y) @ i ==> not(x=y)"

end
